function hole_detection_system()% æ¿æå†²å­”è´¨é‡æ£?æµ‹ç³»ç»?% åŒ…å«å›¾åƒé¢„å¤„ç†ã?è¾¹ç¼˜æå–ã?åœ†å­”è¯†åˆ«ä¸æ‹Ÿåˆã€è½®å»“çº¿è¯†åˆ«ä¸æ‹Ÿåˆå››ä¸ªä¸»è¦æ¨¡å?% è¯»å–å›¾åƒ[filename, pathname] = uigetfile({'*.jpg;*.png;*.bmp', 'å›¾åƒæ–‡ä»¶ (*.jpg, *.png, *.bmp)'});if filename == 0    return;endimg = imread(fullfile(pathname, filename));%% 1. å›¾åƒé¢„å¤„ç†æ¨¡å?% 1.1 å›¾åƒç°åº¦åŒ–ç›˜if size(img, 3) == 3    gray_img = rgb2gray(img);else    gray_img = img;endC:\Users\YTONY\Desktop\BS% 1.2 è‡ªé?‚åº”ä¸­å?¼æ»¤æ³¢å»å™?filtered_img = adaptive_median_filter(gray_img);% 1.3 å¯¹æ¯”åº¦å¢å¼?filtered_img = imadjust(filtered_img, stretchlim(filtered_img, [0.05 0.95]));%% 2. å›¾åƒåˆ†å‰²ä¸ROIæå–æ¨¡å—% 2.1 ä½¿ç”¨å¤šçº§é˜ˆå?¼åˆ†å‰?T1 = graythresh(filtered_img);  % Otsuæ–¹æ³•è®¡ç®—å…¨å±€é˜ˆå??binary_img = imbinarize(filtered_img, T1);% ç¡®ä¿ç›®æ ‡ä¸ºç™½è‰²ï¼ˆå€¼ä¸º1ï¼‰ï¼ŒèƒŒæ™¯ä¸ºé»‘è‰²ï¼ˆå€¼ä¸º0ï¼?if mean(binary_img(:)) < 0.5    binary_img = ~binary_img;end% 2.2 å½¢æ?å­¦å¤„ç†æ”¹å–„è¾¹ç¼˜se1 = strel('disk', 2);  % å‡å°ç»“æ„å…ƒç´ å¤§å°% å…ˆè¿›è¡Œå¼€è¿ç®—å»é™¤å™ªç‚¹binary_img = imopen(binary_img, se1);% å†è¿›è¡Œé—­è¿ç®—è¿æ¥è¾¹ç¼˜binary_img = imclose(binary_img, se1);% 2.3 ä¿ç•™å†…éƒ¨åœ†å­”% æ ‡è®°è¿é?šåŒºåŸ?[L, num] = bwlabel(~binary_img, 8);stats = regionprops(L, 'Area', 'Circularity');% æ‰¾å‡ºåœ†å½¢åŒºåŸŸï¼ˆåœ†å­”ï¼‰is_hole = false(num, 1);for i = 1:num    if stats(i).Area > 30 && stats(i).Area < 1000 && stats(i).Circularity > 0.85  % è°ƒæ•´é¢ç§¯èŒƒå›´å’Œåœ†åº¦é˜ˆå€?        is_hole(i) = true;    endend% é‡å»ºäºŒå?¼å›¾åƒï¼Œä¿ç•™åœ†å­”binary_img_with_holes = binary_img;for i = 1:num    if is_hole(i)        binary_img_with_holes(L == i) = 0;  % å°†åœ†å­”åŒºåŸŸè®¾ä¸ºé»‘è‰?    endend% 2.4 ROIæå–% ç§»é™¤å°é¢ç§¯åŒºåŸ?binary_img = binary_img_with_holes;binary_img = bwareaopen(binary_img, 50);  % é™ä½é¢ç§¯é˜ˆå?¼ä»¥ä¿ç•™æ›´å¤šç»†èŠ‚roi = extract_roi(binary_img);%% 3. è¾¹ç¼˜æå–æ¨¡å—% 3.1 ä½¿ç”¨äºŒå?¼å›¾åƒç›´æ¥æå–è¾¹ç¼?edges = bwperim(~binary_img_with_holes);  % ä½¿ç”¨å¸¦å­”çš„äºŒå€¼å›¾åƒç›´æ¥æå–è¾¹ç¼?% 3.2 ä¼˜åŒ–è¾¹ç¼˜se = strel('disk', 2);  % å¢åŠ ç»“æ„å…ƒç´ å¤§å°edges = imdilate(edges, se);  % è½»å¾®è†¨èƒ€ä»¥å¢å¼ºè¾¹ç¼?edges = bwmorph(edges, 'thin', Inf);  % ç»†åŒ–è¾¹ç¼˜edges = bwareaopen(edges, 30);  % å¢åŠ é¢ç§¯é˜ˆå?¼ï¼Œå»é™¤æ›´å¤šå™ªå£°% æ˜¾ç¤ºä¸­é—´ç»“æœç”¨äºè°ƒè¯•figure('Name', 'å›¾åƒå¤„ç†ä¸­é—´ç»“æœ', 'NumberTitle', 'off');subplot(3,2,1); imshow(gray_img); title('ç°åº¦å›¾åƒ');subplot(3,2,2); imshow(filtered_img); title('æ»¤æ³¢å’Œå¯¹æ¯”åº¦å¢å¼º');subplot(3,2,3); imshow(binary_img); title('äºŒå?¼åŒ–ç»“æœ');subplot(3,2,4); imshow(roi); title('ROIæå–ç»“æœ');subplot(3,2,5); imshow(edges);title('è¾¹ç¼˜æ£?æµ‹ç»“æœï¼ˆåŒ…å«åœ†å­”ï¼?');% æ˜¾ç¤ºç›´æ–¹å›?subplot(3,2,6); imhist(filtered_img);title('å›¾åƒç›´æ–¹å›?');hold on;y_limits = ylim;plot([T1*255 T1*255], [0 y_limits(2)], 'r-', 'LineWidth', 2);legend('ç›´æ–¹å›?', 'é˜ˆå??');hold off;%% 4. åœ†å­”è¯†åˆ«ä¸æ‹Ÿåˆæ¨¡å?% ä½¿ç”¨è¾¹ç¼˜æ£?æµ‹ç»“æœè¿›è¡Œåœ†æ£?æµ?[centers, radii] = imfindcircles(edges, [10 30], ...  % è°ƒæ•´åŠå¾„èŒƒå›´ä¸?10-30åƒç´     'ObjectPolarity', 'bright', ...    'Sensitivity', 0.85, ...  % é™ä½æ•æ„Ÿåº?    'EdgeThreshold', 0.1, ...    'Method', 'PhaseCode');% å¦‚æœæ²¡æœ‰æ£?æµ‹åˆ°åœ†ï¼Œå°è¯•ä½¿ç”¨äºŒå?¼æ©ç ?if isempty(centers)    holes_mask = ~binary_img_with_holes & binary_img;    [centers, radii] = imfindcircles(holes_mask, [10 30], ...  % è¿™é‡Œä¹Ÿè¦è°ƒæ•´åŠå¾„èŒƒå›´        'Sensitivity', 0.85, ...        'EdgeThreshold', 0.1);end%% 5. è½®å»“çº¿è¯†åˆ«ä¸æ‹Ÿåˆæ¨¡å—% ä½¿ç”¨å·¥ä»¶çš„äºŒå€¼å›¾åƒè¾¹ç¼˜è¿›è¡Œè½®å»“æ£€æµ?workpiece_edges = bwperim(binary_img_with_holes);% è·å–ROIåŒºåŸŸstats = regionprops(binary_img_with_holes, 'BoundingBox', 'Area');if ~isempty(stats)    % é€‰æ‹©æœ?å¤§é¢ç§¯çš„åŒºåŸŸä½œä¸ºå·¥ä»¶    [~, max_idx] = max([stats.Area]);    bbox = stats(max_idx).BoundingBox;    roi_x = round(bbox(1));    roi_y = round(bbox(2));    roi_w = round(bbox(3));    roi_h = round(bbox(4));        % åˆ›å»ºROIæ©ç ï¼Œå¹¶æ·»åŠ è¾¹è·    margin = 10;  % æ·»åŠ 10åƒç´ çš„è¾¹è·?    roi_mask = false(size(workpiece_edges));    roi_y_min = max(1, roi_y - margin);    roi_y_max = min(size(workpiece_edges,1), roi_y + roi_h + margin);    roi_x_min = max(1, roi_x - margin);    roi_x_max = min(size(workpiece_edges,2), roi_x + roi_w + margin);    roi_mask(roi_y_min:roi_y_max, roi_x_min:roi_x_max) = true;        % åªä¿ç•™ROIåŒºåŸŸå†…çš„è¾¹ç¼˜    workpiece_edges = workpiece_edges & roi_mask;        % ç§»é™¤å›¾åƒè¾¹æ¡†    border_margin = 20;  % è®¾ç½®è¾¹æ¡†åŒºåŸŸçš„å®½åº?    workpiece_edges(1:border_margin,:) = 0;  % æ¸…é™¤ä¸Šè¾¹æ¡?    workpiece_edges(end-border_margin:end,:) = 0;  % æ¸…é™¤ä¸‹è¾¹æ¡?    workpiece_edges(:,1:border_margin) = 0;  % æ¸…é™¤å·¦è¾¹æ¡?    workpiece_edges(:,end-border_margin:end) = 0;  % æ¸…é™¤å³è¾¹æ¡?end% å¤–è½®å»“æ£€æµ?[H_outer, theta_outer, rho_outer] = hough(workpiece_edges);P_outer = houghpeaks(H_outer, 12, 'threshold', ceil(0.25*max(H_outer(:))));  % å¢åŠ å³°å?¼ç‚¹æ•°é‡ï¼Œé™ä½é˜ˆå€?lines = houghlines(workpiece_edges, theta_outer, rho_outer, P_outer, ...    'FillGap', 25, 'MinLength', 25);  % å¢åŠ å¡«å……é—´éš™ï¼Œå‡å°æœ€å°é•¿åº?% åˆå¹¶ç›¸è¿‘çš„çº¿æ®?if ~isempty(lines)    merged_lines = [];    used = false(1, length(lines));        for i = 1:length(lines)        if used(i)            continue;        end                current_line = lines(i);        used(i) = true;                % è®¡ç®—å½“å‰çº¿æ®µçš„è§’åº?        dx = current_line.point2(1) - current_line.point1(1);        dy = current_line.point2(2) - current_line.point1(2);        angle1 = atan2(dy, dx);                % å¯»æ‰¾å¯ä»¥åˆå¹¶çš„çº¿æ®?        for j = i+1:length(lines)            if used(j)                continue;            end                        % è®¡ç®—å¾…æ¯”è¾ƒçº¿æ®µçš„è§’åº¦            dx = lines(j).point2(1) - lines(j).point1(1);            dy = lines(j).point2(2) - lines(j).point1(2);            angle2 = atan2(dy, dx);                        % æ”¾å®½åˆå¹¶æ¡ä»¶            angle_diff = abs(mod(angle1 - angle2 + pi, pi));            if angle_diff < 0.3 && ...  % å¢åŠ è§’åº¦å®¹å·®               (norm(current_line.point2 - lines(j).point1) < 40 || ...  % å¢åŠ è·ç¦»å®¹å·®                norm(current_line.point1 - lines(j).point2) < 40)                                % åˆå¹¶ä¸¤æ¡çº¿æ®µ                points = [current_line.point1; current_line.point2;                          lines(j).point1; lines(j).point2];                [~, idx] = max(pdist2(mean(points), points));                opposite_idx = mod(idx + 2, 4);                if opposite_idx == 0                    opposite_idx = 4;                end                                current_line.point1 = points(idx, :);                current_line.point2 = points(opposite_idx, :);                used(j) = true;            end        end                merged_lines = [merged_lines, current_line];    end        lines = merged_lines;end% æ·»åŠ è½®å»“é—­åˆå¤„ç†if ~isempty(lines)    % æ‰¾åˆ°æ‰?æœ‰çº¿æ®µç«¯ç‚?    endpoints = [];    for i = 1:length(lines)        endpoints = [endpoints; lines(i).point1; lines(i).point2];    end        % å¯»æ‰¾æœªé—­åˆçš„ç«¯ç‚¹ï¼ˆä¸å…¶ä»–ç«¯ç‚¹è·ç¦»è¾ƒè¿œçš„ç‚¹ï¼?    n_endpoints = size(endpoints, 1);    unclosed = false(n_endpoints, 1);    for i = 1:n_endpoints        min_dist = inf;        for j = 1:n_endpoints            if i ~= j                dist = norm(endpoints(i,:) - endpoints(j,:));                min_dist = min(min_dist, dist);            end        end        if min_dist > 30  % è®¾ç½®é—­åˆé˜ˆå??            unclosed(i) = true;        end    end        % è¿æ¥æœªé—­åˆçš„ç«¯ç‚¹    unclosed_points = endpoints(unclosed,:);    if size(unclosed_points, 1) >= 2        for i = 1:2:size(unclosed_points, 1)            if i+1 <= size(unclosed_points, 1)                % åˆ›å»ºä¸åŸå§‹çº¿æ®µç»“æ„ç›¸åŒçš„æ–°çº¿æ®?                new_line = struct('point1', unclosed_points(i,:), ...                                'point2', unclosed_points(i+1,:), ...                                'theta', 0, ...                                'rho', 0);                lines = [lines, new_line];            end        end    endend% è·å–è§’ç‚¹corners = [];if length(lines) >= 2    for i = 1:length(lines)-1        for j = i+1:length(lines)            corner = line_intersection(lines(i), lines(j));            if ~isempty(corner)                % æ£?æŸ¥è§’ç‚¹æ˜¯å¦åœ¨ROIåŒºåŸŸå†?                if corner(1) >= roi_x && corner(1) <= roi_x+roi_w && ...                   corner(2) >= roi_y && corner(2) <= roi_y+roi_h                    corners = [corners; corner];                end            end        end    end        % åˆå¹¶ç›¸è¿‘çš„è§’ç‚?    if ~isempty(corners)        corners = merge_close_corners(corners);    endend%% 6. æ˜¾ç¤ºç»“æœdisplay_results(img, edges, centers, radii, lines, corners);endfunction filtered = adaptive_median_filter(img)% è‡ªé?‚åº”ä¸­å?¼æ»¤æ³¢å®ç?[m, n] = size(img);filtered = zeros(m, n);min_window = 3;max_window = 7;for i = 1:m    for j = 1:n        window_size = min_window;        while window_size <= max_window            window = get_window(img, i, j, window_size);            z_min = min(window(:));            z_max = max(window(:));            z_med = median(window(:));            z_xy = img(i,j);                        if z_med > z_min && z_med < z_max                if z_xy > z_min && z_xy < z_max                    filtered(i,j) = z_xy;                else                    filtered(i,j) = z_med;                end                break;            else                window_size = window_size + 2;                if window_size > max_window                    filtered(i,j) = z_med;                end            end        end    endendfiltered = uint8(filtered);endfunction window = get_window(img, i, j, window_size)% è·å–å›¾åƒçª—å£half = floor(window_size/2);[m, n] = size(img);row_min = max(1, i-half);row_max = min(m, i+half);col_min = max(1, j-half);col_max = min(n, j+half);window = img(row_min:row_max, col_min:col_max);endfunction threshold = iterative_threshold(img)% è¿­ä»£æ³•æ±‚æœ?ä½³é˜ˆå€?threshold = mean(img(:));delta = 0.1;while true    g1 = img(img >= threshold);    g2 = img(img < threshold);    m1 = mean(g1);    m2 = mean(g2);    new_threshold = (m1 + m2) / 2;    if abs(new_threshold - threshold) < delta        break;    end    threshold = new_threshold;endendfunction roi = extract_roi(binary_img)% ROIæå–stats = regionprops(binary_img, 'BoundingBox');if ~isempty(stats)    bbox = stats(1).BoundingBox;    x = round(bbox(1));    y = round(bbox(2));    w = round(bbox(3));    h = round(bbox(4));    roi = binary_img(y:y+h-1, x:x+w-1);else    roi = binary_img;endendfunction [centers, radii] = detect_and_fit_circles(edges)% åœ†å­”è¯†åˆ«ä¸æ‹Ÿå?[centers, radii] = imfindcircles(edges, [20 100], 'Sensitivity', 0.85);if isempty(centers)    centers = [];    radii = [];endendfunction [lines, corners] = detect_and_fit_contours(edges)% è½®å»“çº¿è¯†åˆ«ä¸æ‹Ÿåˆ[H, theta, rho] = hough(edges);P = houghpeaks(H, 10, 'threshold', ceil(0.3*max(H(:))));lines = houghlines(edges, theta, rho, P, 'FillGap', 5, 'MinLength', 7);% è·å–è§’ç‚¹corners = [];if length(lines) >= 2    for i = 1:length(lines)-1        for j = i+1:length(lines)            line1 = lines(i);            line2 = lines(j);            corner = line_intersection(line1, line2);            if ~isempty(corner)                corners = [corners; corner];            end        end    endendendfunction corner = line_intersection(line1, line2)% è®¡ç®—ä¸¤ç›´çº¿äº¤ç‚?x1 = line1.point1(1);y1 = line1.point1(2);x2 = line1.point2(1);y2 = line1.point2(2);x3 = line2.point1(1);y3 = line2.point1(2);x4 = line2.point2(1);y4 = line2.point2(2);denominator = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4);if abs(denominator) < 1e-10    corner = [];    return;endx = ((x1*y2-y1*x2)*(x3-x4) - (x1-x2)*(x3*y4-y3*x4)) / denominator;y = ((x1*y2-y1*x2)*(y3-y4) - (y1-y2)*(x3*y4-y3*x4)) / denominator;corner = [x, y];endfunction display_results(original_img, edges, centers, radii, lines, corners)% æ˜¾ç¤ºæ£?æµ‹ç»“æ?figure('Name', 'æ¿æå†²å­”è´¨é‡æ£?æµ‹ç»“æ?', 'NumberTitle', 'off');% åŸå›¾subplot(2,2,1);imshow(original_img);title('åŸå§‹å›¾åƒ');% è¾¹ç¼˜æ£?æµ‹ç»“æ?subplot(2,2,2);imshow(edges);title('è¾¹ç¼˜æ£?æµ‹ç»“æ?');% åœ†å­”æ£?æµ‹ç»“æ?subplot(2,2,3);imshow(original_img);hold on;if ~isempty(centers)    viscircles(centers, radii, 'EdgeColor', 'b', 'LineWidth', 1.5);    % æ ‡æ³¨åœ†å¿ƒå’ŒåŠå¾?    for i = 1:size(centers, 1)        plot(centers(i,1), centers(i,2), 'b+', 'MarkerSize', 10, 'LineWidth', 2);        text(centers(i,1)+10, centers(i,2)+10, ...             sprintf('R=%.1f', radii(i)), ...             'Color', 'blue', 'FontSize', 8);    endendtitle('åœ†å­”æ£?æµ‹ç»“æ?');hold off;% è½®å»“çº¿æ£€æµ‹ç»“æ?subplot(2,2,4);imshow(original_img);hold on;% ç»˜åˆ¶è½®å»“çº?for k = 1:length(lines)    xy = [lines(k).point1; lines(k).point2];    plot(xy(:,1), xy(:,2), 'LineWidth', 2, 'Color', 'green');end% ç»˜åˆ¶è§’ç‚¹if ~isempty(corners)    plot(corners(:,1), corners(:,2), 'r*', 'MarkerSize', 10);endtitle('è½®å»“çº¿æ£€æµ‹ç»“æ?');hold off;endfunction merged_corners = merge_close_corners(corners)% åˆå¹¶ç›¸è¿‘çš„è§’ç‚?if isempty(corners)    merged_corners = corners;    return;end% è®¾ç½®è·ç¦»é˜ˆå??dist_threshold = 10;% åˆå§‹åŒ–æ ‡è®°æ•°ç»?n = size(corners, 1);merged = false(n, 1);merged_corners = [];% éå†æ‰?æœ‰è§’ç‚?for i = 1:n    if merged(i)        continue;    end        % è®¡ç®—å½“å‰è§’ç‚¹ä¸å…¶ä»–è§’ç‚¹çš„è·ç¦»    distances = sqrt(sum((corners - corners(i,:)).^2, 2));    close_corners_idx = distances < dist_threshold;        % è®¡ç®—ç›¸è¿‘è§’ç‚¹çš„å¹³å‡ä½ç½?    cluster_corners = corners(close_corners_idx, :);    merged_corner = mean(cluster_corners, 1);        % æ·»åŠ åˆå¹¶åçš„è§’ç‚¹    merged_corners = [merged_corners; merged_corner];    merged(close_corners_idx) = true;endend 